---
type: lesson
title: Compound States
focus: /src/machine.ts
---

## Compound States

In this lesson, we'll get familiar with compound (or parent/child) states. Compound states are states that contain other states. They are useful for organizing and structuring complex state machines. Compound states can have nested states, which can have their own nested states, and so on. This allows you to create a hierarchical structure of states that can represent complex behavior.

We'll also use a special kind of transition called a "delayed transition" to transition from one state to another after a certain amount of time has passed. This is useful for emulating the time it takes for a process to complete, such as a loading a media player.

Let's take a look at an example of a simple state machine with compound states (technically a statechart). This statechart represents an arcane technology called a CD player üòÅ, in which the CDs are placed in a tray and mechnically closed. It can be in one of three states:

- "Opened", "Closed", and "Closing".
- The "Closed" state is a parent state.
- It has three child states: "Stopped", "Playing", and "Paused".
- The "Closing" state transitions to the "Closed" state after 1500ms.

#### Model

<a
  href="https://stately.ai/registry/editor/6ad630e7-c4f1-40e5-8068-4c0a0398a8e9?machineId=a5701504-59a3-4092-9bd4-3972be705357&mode=design"
  target="_blank"
  alt="First Machine"
>
  Open in Stately Studio
</a>
<img src="/first-machine.png" alt="First Machine" />

#### Code

Here's the code in XState:

```ts
import { setup } from "xstate";

export const machine = setup({
  types: {
    events: {} as
      | { type: "OPEN" }
      | { type: "PLAY" }
      | { type: "STOP" }
      | { type: "PAUSE" }
      | { type: "CLOSE" },
  },
}).createMachine({
  initial: "Opened",
  states: {
    Opened: {
      on: {
        CLOSE: {
          target: "Closing",
        },
      },
    },
    Closing: {
      after: {
        "1500": {
          target: "Closed",
        },
      },
    },
    Closed: {
      initial: "Stopped",
      on: {
        OPEN: {
          target: "Opened",
        },
      },
      states: {
        Stopped: {
          on: {
            PLAY: {
              target: "Playing",
            },
          },
        },
        Playing: {
          on: {
            PAUSE: {
              target: "Paused",
            },
            STOP: {
              target: "Stopped",
            },
          },
        },
        Paused: {
          on: {
            PLAY: {
              target: "Playing",
            },
            STOP: {
              target: "Stopped",
            },
          },
        },
      },
    },
  },
});
```

To use this machine in our React component, we'll use the `useMachine` hook again:

```tsx
import { machine } from "./machine";
import { useMachine } from "@xstate/react";

function App() {
  const [state, send] = useMachine(machine);
  const isPlaying = state.matches({ Closed: "Playing" });
  const isOpened = state.matches("Opened");
  return (
    <div>
      <h1>{JSON.stringify(state.value)}</h1>
      <button
        onClick={() =>
          send({
            type: isOpened ? "CLOSE" : "OPEN",
          })
        }
      >
        {isOpened ? "close" : "open"}
      </button>
      <button
        onClick={() =>
          send({
            type: isPlaying ? "PAUSE" : "PLAY",
          })
        }
      >
        {isPlaying ? "pause" : "play"}
      </button>
      <button
        disabled={isOpened || !isPlaying}
        onClick={() => {
          send({ type: "STOP" });
        }}
      >
        stop
      </button>
    </div>
  );
}

export default App;
```

##### Key Points

- We're using the `matches` method to check if the current state matches a specific state.
- We're using the `after` property to transition to another state after a certain amount of time has passed. In this case, we're transitioning from the "Closing" state to the "Closed.Playing" state after 1500ms.

##### In Practice

You can see an example of this in the code editor to you right. Click the button in the preview panel to toggle betweeen states. Notice how the button's text changes from "On" to "Off" and back again, reflecting the current state of the machine. [Open in stackblitz](https://stackblitz.com/edit/vitejs-vite-bzhhga?file=src%2Fmachine.ts)

#### Exercise

1. Change the event type from "switch" to "toggle" in the machine definition.
2. Update the event type in the `send` method to match the new event type.
3. Test the changes by clicking the button in the preview panel.
4. Change the the name of the first state from "Off" to "Inactive" and the second state from "On" to "Active".
5. Update the button's text to reflect the new state names.
6. Test the changes by clicking the button in the preview panel.

#### Summary

In this lesson, you learned how to integrate XState with React using the `useMachine` hook. This hook provides the current state and a `send` function to send events to the machine.

#### Resources

- [XState Docs](https://stately.ai/docs/xstate)
- [Stately Studio](https://stately.ai/registry/editor/6ad630e7-c4f1-40e5-8068-4c0a0398a8e9?machineId=a5701504-59a3-4092-9bd4-3972be705357&mode=design)
